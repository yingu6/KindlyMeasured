<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-30">
<meta name="description" content="Why I built a reading time tracker, the zigzags along the way, and the Shortcuts setup that finally stuck">

<title>Kindly Measured Reading [1/3]: The Reading Time Tracker – Kindly Measured</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../logo.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-2fef5ea3f8957b3e4ecc936fc74692ca.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ad990f474b20aa6d6c2788181d1a6a3b.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-3fb9eac868718f14af97f5aa7bcaf007.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-ad990f474b20aa6d6c2788181d1a6a3b.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Kindly Measured Reading [1/3]: The Reading Time Tracker – Kindly Measured">
<meta property="og:description" content="Why I built a reading time tracker, the zigzags along the way, and the Shortcuts setup that finally stuck">
<meta property="og:site_name" content="Kindly Measured">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Kindly Measured</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-i-wanted-constraints-first" id="toc-what-i-wanted-constraints-first" class="nav-link active" data-scroll-target="#what-i-wanted-constraints-first">What I wanted (constraints first)</a></li>
  <li><a href="#attempt-1-shortcuts-notes-works-but-messy" id="toc-attempt-1-shortcuts-notes-works-but-messy" class="nav-link" data-scroll-target="#attempt-1-shortcuts-notes-works-but-messy">Attempt 1: Shortcuts + Notes (works, but messy)</a></li>
  <li><a href="#attempt-2-shortcuts-numbersexcel-not-working-on-apple-watch" id="toc-attempt-2-shortcuts-numbersexcel-not-working-on-apple-watch" class="nav-link" data-scroll-target="#attempt-2-shortcuts-numbersexcel-not-working-on-apple-watch">Attempt 2: Shortcuts + Numbers/Excel (not working on Apple Watch)</a>
  <ul class="collapse">
  <li><a href="#why-this-was-appealing" id="toc-why-this-was-appealing" class="nav-link" data-scroll-target="#why-this-was-appealing">Why this was appealing</a></li>
  <li><a href="#why-i-didnt-stick-with-it" id="toc-why-i-didnt-stick-with-it" class="nav-link" data-scroll-target="#why-i-didnt-stick-with-it">Why I didn’t stick with it</a></li>
  </ul></li>
  <li><a href="#final-approach-shortcuts-calendar-finally-works" id="toc-final-approach-shortcuts-calendar-finally-works" class="nav-link" data-scroll-target="#final-approach-shortcuts-calendar-finally-works">Final Approach: Shortcuts + Calendar (finally works!)</a>
  <ul class="collapse">
  <li><a href="#how-it-works" id="toc-how-it-works" class="nav-link" data-scroll-target="#how-it-works">How it works</a></li>
  <li><a href="#why-it-works-surprisingly-well" id="toc-why-it-works-surprisingly-well" class="nav-link" data-scroll-target="#why-it-works-surprisingly-well">Why it works surprisingly well</a></li>
  </ul></li>
  <li><a href="#reflections" id="toc-reflections" class="nav-link" data-scroll-target="#reflections">Reflections</a>
  <ul class="collapse">
  <li><a href="#shorcuts-learning-curve" id="toc-shorcuts-learning-curve" class="nav-link" data-scroll-target="#shorcuts-learning-curve">Shorcuts learning curve</a></li>
  <li><a href="#talking-through-an-idea-really-helps" id="toc-talking-through-an-idea-really-helps" class="nav-link" data-scroll-target="#talking-through-an-idea-really-helps">Talking through an idea really helps</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Kindly Measured Reading [1/3]: The Reading Time Tracker</h1>
  <div class="quarto-categories">
    <div class="quarto-category">reading</div>
    <div class="quarto-category">tracking</div>
    <div class="quarto-category">shortcuts</div>
    <div class="quarto-category">calendar</div>
    <div class="quarto-category">ios</div>
  </div>
  </div>

<div>
  <div class="description">
    Why I built a reading time tracker, the zigzags along the way, and the Shortcuts setup that finally stuck
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>I’ve been using a Kindle for reading and Goodreads for reviews and logging. But neither gives me the kind of session-level data (or metadata) I want to understand my reading habits over time.</p>
<p>What I really wanted was a simple tracker that could capture:</p>
<ul>
<li>the date and time of each reading session</li>
<li>the title of the book I read during that session</li>
</ul>
<p>After looking into what was already available, I found that popular reading tracker apps (like Bookly and Bookmory) still didn’t fully meet my needs—both in design and in how accessible the data was—unless I paid for a subscription. And since the data I wanted felt fairly minimal, I started wondering: could I build something lightweight that stays local and gives me full control?</p>
<p>After talking it through with ChatGPT, I decided to try a route that’s already built into the Apple ecosystem: <strong>Shortcuts</strong>, which works across iPhone and Apple Watch.</p>
<p>This post documents the path I took—complete with a few zigzags—the setup that <em>actually stuck</em>, and the reflections I had along the way.</p>
<section id="what-i-wanted-constraints-first" class="level2">
<h2 class="anchored" data-anchor-id="what-i-wanted-constraints-first">What I wanted (constraints first)</h2>
<p>My original idea was simple, but the constraints became clearer (and more realistic) as I built and tested the workflow:<br>
- <strong>Quick logging from Apple Watch + iPhone</strong> (ideally Watch-first, since I often don’t have my phone nearby while reading—this turned out to be a major constraint early on)<br>
- <strong>Start/end timestamps</strong>, so I can calculate duration later<br>
- <strong>A book title logged into each session</strong><br>
- <strong>Data that’s easy to export and analyze in R/RMarkdown</strong><br>
- <strong>Low maintenance</strong>: minimal typing, minimal file management (I don’t want tracking to add friction to a hobby)<br>
- <strong>Reusable/replicable</strong>: I realized the same approach could later track other hobbies too (like drawing), not just reading</p>
</section>
<section id="attempt-1-shortcuts-notes-works-but-messy" class="level2">
<h2 class="anchored" data-anchor-id="attempt-1-shortcuts-notes-works-but-messy">Attempt 1: Shortcuts + Notes (works, but messy)</h2>
<p>My first <a href="https://www.icloud.com/shortcuts/d24beb697f5845ae8344ca21f70a261a">prototype</a> used <strong>Shortcuts</strong> to append reading logs into <strong>Apple Notes</strong>. It worked, but Notes has an important limitation in this context: each appended value becomes its own line. That means a single session quickly turns into multiple lines—book title, start time, stop time, plus separators to keep the log readable (and editable if I logged something wrong).</p>
<p>Below is what the raw data looked like after a few iterations:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Book: The Story of a New Name
Start at
2025-12-29T18:28:27-05:00
Stop at
2025-12-29T18:28:30-05:00
------
Book: Kite Runner
Start at
2025-12-29T18:39:24-05:00
Stop at
2025-12-29T18:39:29-05:00
------
Book: The Story of a New Name
Start at
2025-12-29T19:28:27-05:00
Stop at
2025-12-29T19:28:30-05:00
------</code></pre>
</div>
</div>
<p>From a data perspective, this wasn’t <em>too</em> bad. If I logged one reading session per day, I’d end up with roughly 365 × 6 = 2,190 lines by the end of the year. In theory, I could copy the note into R and run a parsing script built around this structure.</p>
<p>Still, my data instincts kept nagging at me: <em>this can’t be the best way.</em> The format felt not only rudimentary but also fragile—easy to break if I ever tweaked the wording, missed a line, or wanted to add one more field later.</p>
<p>So I kept digging and tried another approach.</p>
</section>
<section id="attempt-2-shortcuts-numbersexcel-not-working-on-apple-watch" class="level2">
<h2 class="anchored" data-anchor-id="attempt-2-shortcuts-numbersexcel-not-working-on-apple-watch">Attempt 2: Shortcuts + Numbers/Excel (not working on Apple Watch)</h2>
<p>Next I tried a more “structured data” approach. I found a <a href="https://www.reddit.com/r/shortcuts/comments/1dnxtqe/work_time_tracking_using_automation_on_shortcuts/">Reddit post</a> that shared a <a href="https://www.icloud.com/shortcuts/0c47d79424034eb3b421dfe07f5f264b">work time-tracking workflow</a> built with Shortcuts, which logs entries directly into a spreadsheet. I used that idea as a starting point and adapted it for reading.</p>
<p>Its main difference from the Notes prototype is that <strong>Numbers becomes the database</strong>. Instead of writing raw text that I’d need to parse later, each session becomes a row in a spreadsheet—already structured, readable, and editable.</p>
<p>I was able to quickly modify the shortcut to fit my needs. Here is the updated <a href="https://www.icloud.com/shortcuts/49a3d5b36b3a4e769d6e2d46db1db234">shortcut</a>. In the <a href="files/Reading Track.numbers">Numbers file</a>, I used three sheets to collect raw inputs and then clean the data:<br>
- <strong>Start</strong>: logs the book title + start timestamp<br>
- <strong>End</strong>: logs the stop timestamp<br>
- <strong>Time Tracking</strong>: uses formulas to join the two logs, cleans up the fields, and calculates duration per session.</p>
<section id="why-this-was-appealing" class="level3">
<h3 class="anchored" data-anchor-id="why-this-was-appealing">Why this was appealing</h3>
<ul>
<li>The data was immediately tidy: rows and columns, no parsing required.</li>
<li>It was easy to review and correct mistakes.</li>
<li>In theory, I could even do lightweight summaries inside Numbers.</li>
</ul>
</section>
<section id="why-i-didnt-stick-with-it" class="level3">
<h3 class="anchored" data-anchor-id="why-i-didnt-stick-with-it">Why I didn’t stick with it</h3>
<p>This approach mostly worked—but it failed one of my core constraints. - <strong>Too much friction on the phone.</strong> Every time I ran the shortcut, Numbers popped open on my iPhone, and I had to manually close it. These two steps are rather redundant. - <strong>Dealbreaker: it doesn’t work on Apple Watch.</strong> Numbers isn’t available on Apple Watch, so the shortcut can’t run there. And since I often read without my phone nearby, Watch-first logging wasn’t optional for me.</p>
<p>At this point, I was tempted to fall back to the Notes method—until I found a better alternative.</p>
</section>
</section>
<section id="final-approach-shortcuts-calendar-finally-works" class="level2">
<h2 class="anchored" data-anchor-id="final-approach-shortcuts-calendar-finally-works">Final Approach: Shortcuts + Calendar (finally works!)</h2>
<p>While browsing more time-tracking workflows on Reddit, I came across an idea I hadn’t seriously considered: <strong>tracking time by creating Calendar events</strong>. My first reaction was that it felt like an unnecessary extra system. But when I was describing my experiments to my husband, it finally clicked—Calendar could <em>be</em> the database. I already use it extensively, it’s available on Apple Watch, and it stores start/end timestamps natively. Better yet, I could export everything later and analyze it in R.</p>
<p>This ended up being the simplest solution—while also offers much more than I expected.</p>
<section id="how-it-works" class="level3">
<h3 class="anchored" data-anchor-id="how-it-works">How it works</h3>
<p>At a high level, this <a href="https://www.icloud.com/shortcuts/293b167ed3524085ad5915aa1d65d949">shortcut</a> does three things:</p>
<ul>
<li><strong>Stores a book list</strong> inside the shortcut (so I can select a title quickly without typing)</li>
<li><strong>On “Start”</strong>, saves the start timestamp to a small <code>.txt</code> file (stored in the Shortcuts folder on iCloud)</li>
<li><strong>On “Stop”</strong>, creates a Calendar event using:
<ul>
<li><strong>Event title:</strong> the selected book title<br>
</li>
<li><strong>Start time:</strong> retrieved from the saved <code>.txt</code> file<br>
</li>
<li><strong>End time:</strong> the current time when I stop the shortcut</li>
</ul></li>
</ul>
</section>
<section id="why-it-works-surprisingly-well" class="level3">
<h3 class="anchored" data-anchor-id="why-it-works-surprisingly-well">Why it works surprisingly well</h3>
<ul>
<li>Calendar events already contain the two key fields I need: start and end</li>
<li>It’s easy to attach metadata like book title through Shortcuts</li>
<li>Reviewing and correcting sessions is simple—each session is just an editable event in the Calendar</li>
<li>Calendar sync is automatic across devices, including <strong>Apple Watch</strong> (a major constraint solved)</li>
<li>Exporting to <code>.ics</code> is standard and reliable; R has dedicated package to retrieve data from <code>.ics</code></li>
<li>A dedicated calendar keeps the dataset clean (no mixing with real appointments)</li>
<li>The same approach can be reused for other activities and hobbies (like drawing) with almost no changes</li>
</ul>
<p>What I like most is that it fits naturally into how I already use Calendar. I’m not trying to quantify reading habit as a tool for self-discipline. Instead, I’m more interested in seeing <em>how</em> reading shows up in my life—-when it happens, how consistent or inconsistent it is, and how my reading time spreads across different books and genres. Having sessions appear on my calendar makes reading time more visible, and it gives me a gentle, non-rigid way to notice patterns over time–patterns that will likely help me understand myself a little better in the future.</p>
</section>
</section>
<section id="reflections" class="level2">
<h2 class="anchored" data-anchor-id="reflections">Reflections</h2>
<p>I will talk about the data export from Calendar and analysis in R in details in the next post. Here, I want to pause and share a few reflections from the process itself – what surprised me, what helped, and what I’d do again.</p>
<section id="shorcuts-learning-curve" class="level3">
<h3 class="anchored" data-anchor-id="shorcuts-learning-curve">Shorcuts learning curve</h3>
<p>Initially, I went back and forth on whether I should use existing tools to build this time-tracking workflow or take the more ambitious route and try to build an app. The app idea might sound unrealistic for someone without a software engineering background, but I’ve always liked learning new things, and this felt like a good excuse/motive to try. With today’s AI coding tools, the question isn’t really <em>whether</em> it’s possible, but how much time I’d be willing to invest.</p>
<p>In the end, I chose the first route—using Shortcuts—because I wanted the process to be relatively quick and less demanding. If the project took too long, it would start stealing time from the very thing I was trying to support: reading. Shortcuts felt like a good middle ground: versatile enough to make life easier, but lightweight enough to keep the effort proportional to the goal. I’m still interested in building a small app one day—just not for this project, and not right now.</p>
<p>At work, I’ve built quite a few automated workflows using tools like Power Automate, AppleScript, and R. So when I first started exploring Shortcuts, I didn’t expect much of a learning curve. I assumed I could follow a set of steps and get a working shortcut quickly.</p>
<p>That confidence didn’t last long.</p>
<p>My first attempt failed pretty dramatically, and it took me at least two hours to accept that I needed to step back and look at real examples before I could build something reliable. In hindsight, the learning curve makes sense. It came from a few places:</p>
<ul>
<li><strong>The action vocabulary is its own world.</strong> Shortcuts has a specific set of building blocks, and you only get fluent by learning what exists (and what doesn’t).</li>
<li><strong>Each action has a narrow “shape.”</strong> Compared with tools like Power Automate (not a perfect comparison, but still), Shortcuts can feel more constrained in what each step can do—so you often need extra steps to get to the same result.</li>
<li><strong>The environment is different.</strong> I’m much more practiced at building automation on a laptop. Designing something that needs to run smoothly on an iPhone—and especially on an Apple Watch—forced me to think differently about interaction, input, and friction.</li>
</ul>
</section>
<section id="talking-through-an-idea-really-helps" class="level3">
<h3 class="anchored" data-anchor-id="talking-through-an-idea-really-helps">Talking through an idea really helps</h3>
<p>I still can’t believe the turning point came from a casual after-dinner conversation with my husband. I was explaining why my day felt rough—multiple failed Shortcut attempts—and what I had managed to achieve so far. I mentioned that I’d seen someone use Calendar as the “database” for time tracking. He asked a simple question: <em>how does that work?</em> And that question exposed a gap I hadn’t even noticed—I’d never really tested the Calendar option, and I wasn’t sure whether (or how) I could export all events from a dedicated calendar in a usable way.</p>
<p>That was the moment the solution clicked.</p>
<p>The turning point didn’t happen when I asked ChatGPT a hundred questions, and it didn’t happen when I collected more Shortcut examples. It happened when I tried to explain the problem out loud to another person.</p>
<p>This <strong>learning-by-teaching</strong> idea isn’t new—it’s a well-studied learning strategy. One related finding is the <strong>protégé effect</strong>: when learners expect to teach (or feel responsible for someone else’s learning), they often invest more effort and learn more deeply <span class="citation" data-cites="chase2009">(<a href="#ref-chase2009" role="doc-biblioref">Chase et al., 2009</a>)</span>. In classroom settings, a widely used cousin of this idea is <strong>Peer Instruction</strong>, an evidence-based approach with a large research base across STEM disciplines <span class="citation" data-cites="vickrey2015">(<a href="#ref-vickrey2015" role="doc-biblioref">Vickrey et al., 2015</a>)</span>. A closely related mechanism is <strong>self-explanation</strong>—putting your reasoning into words as you learn—which has also been shown to improve understanding even with minimal prompting <span class="citation" data-cites="chi1994">(<a href="#ref-chi1994" role="doc-biblioref">Chi et al., 1994</a>)</span>.</p>
<p>In other words, when you try to teach—or even just explain—your thinking, you’re forced to organize it, name the assumptions you’ve been making, and notice what you don’t actually understand yet. Often, the “aha” comes not from new information, but from restructuring what you already know.</p>
<p>On the other side of the story, my husband was being a really good listener. It reminded me of what good therapists often do: ask the right questions, hold the space, and help people arrive at their own answers.</p>
<hr>
<p>
This work is licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="CC" style="max-width: 1em;max-height:1em;margin-left: .2em;"> <img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="BY" style="max-width: 1em;max-height:1em;margin-left: .2em;"> <img src="https://mirrors.creativecommons.org/presskit/icons/sa.svg" alt="SA" style="max-width: 1em;max-height:1em;margin-left: .2em;">
</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-chase2009" class="csl-entry" role="listitem">
Chase, C. C., Chin, D. B., Oppezzo, M. A., &amp; Schwartz, D. L. (2009). Teachable agents and the prot<span>é</span>g<span>é</span> effect: Increasing the effort towards learning. <em>Journal of Science Education and Technology</em>, <em>18</em>(4), 334–352. <a href="https://doi.org/10.1007/s10956-009-9180-4">https://doi.org/10.1007/s10956-009-9180-4</a>
</div>
<div id="ref-chi1994" class="csl-entry" role="listitem">
Chi, M. T. H., De Leeuw, N., Chiu, M.-H., &amp; Lavancher, C. (1994). Eliciting self-explanations improves understanding. <em>Cognitive Science</em>, <em>18</em>(3), 439–477. <a href="https://doi.org/10.1016/0364-0213(94)90016-7">https://doi.org/10.1016/0364-0213(94)90016-7</a>
</div>
<div id="ref-vickrey2015" class="csl-entry" role="listitem">
Vickrey, T., Rosploch, K., Rahmanian, R., Pilarz, M., &amp; Stains, M. (2015). Research-based implementation of peer instruction: A literature review. <em>CBE—Life Sciences Education</em>, <em>14</em>(1), es3. <a href="https://doi.org/10.1187/cbe.14-11-0198">https://doi.org/10.1187/cbe.14-11-0198</a>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/yingu6\.github\.io\/KindlyMeasured\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>